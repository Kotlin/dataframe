package org.jetbrains.kotlinx.dataframe.jupyter

import org.jetbrains.kotlinx.dataframe.codeGen.CodeWithConverter
import org.jetbrains.kotlinx.jupyter.api.KotlinKernelHost
import org.jetbrains.kotlinx.jupyter.api.VariableName
import kotlin.reflect.KProperty
import kotlin.reflect.KType

internal fun KotlinKernelHost.execute(codeWithConverter: CodeWithConverter, argument: String): VariableName? {
    val snippets = codeWithConverter.with(argument)
    return if (snippets.any { it.isNotBlank() }) {
        var variableName: String? = null
        for (snippet in snippets) {
            val result = execute(snippet)
            if (codeWithConverter.hasConverter) {
                variableName = result.name
            }
        }
        // Any code generated by DataFrame will always have the variable name defined in the last snippet,
        // so returning that here should be safe.
        variableName
    } else {
        null
    }
}

internal fun KotlinKernelHost.execute(
    codeWithConverter: CodeWithConverter,
    property: KProperty<*>,
    type: KType,
): VariableName? {
    val variableName = "(${property.name}${if (property.returnType.isMarkedNullable) "!!" else ""} as $type)"
    return execute(codeWithConverter, variableName)
}
