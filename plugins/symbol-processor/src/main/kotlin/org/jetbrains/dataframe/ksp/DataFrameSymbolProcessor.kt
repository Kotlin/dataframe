package org.jetbrains.dataframe.ksp

import com.google.devtools.ksp.processing.KSPLogger
import com.google.devtools.ksp.processing.Resolver
import com.google.devtools.ksp.processing.SymbolProcessor
import com.google.devtools.ksp.symbol.KSAnnotated

class DataFrameSymbolProcessor(
    private val codeGenerator: com.google.devtools.ksp.processing.CodeGenerator,
    private val logger: KSPLogger,
    private val resolutionDir: String?,
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val extensionsGenerator = ExtensionsGenerator(resolver, codeGenerator, logger)
        val (validDataSchemas, invalidDataSchemas) = extensionsGenerator.resolveDataSchemaDeclarations()
        validDataSchemas.forEach {
            val file = it.origin.containingFile ?: return@forEach
            extensionsGenerator.generateExtensions(file, it.origin, it.properties)
            extensionsGenerator.generateConstructors(it, file)
        }

        val dataSchemaGenerator = DataSchemaGenerator(resolver, resolutionDir, logger, codeGenerator)
        val importStatements = dataSchemaGenerator.resolveImportStatements()
        importStatements.forEach { importStatement ->
            dataSchemaGenerator.generateDataSchema(importStatement)
        }

        // by returning invalidDataSchemas we defer the processing of incomplete DataSchema declarations
        // for example when DataSchema declaration references another one generated by @file:ImportDataSchema
        return invalidDataSchemas
    }
}
